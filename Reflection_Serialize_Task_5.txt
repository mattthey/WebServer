	Задача №5 - Reflection - ООП


    Цель данного упражнения познакомить студента с особенностями reflection в Java/С# и
    реализовать сериализатор данных для клиент-серверного взаимодействия.
    Далее задача формулируется для Java. Сериализация - преобразование объекта в массив байтов.
    Десериализация - обратный процесс. Соотвественно, логика такая:

	1. Создаем объект с данными.
	2. Сериализуем объект с данными, получаем массив данных.
	3. Отправляем массив байтов на сервер.
	4. На сервере происходит десериализация обратно в объект.
	5. Обработка данных.

	То есть необходимо написать сериализатор данных для передачи по сети произвольного объекта.
	ВАЖНО: с учетом того, что сервер и клиент могут быть на разных языках, то сериализатор должен существовать
	в каждом из них. Далее приводится сигнатура необходимых методов:

public class Serializator
{
	public byte[] Serialize(Object o) - перевод произвольного объекта в массив
	public T Deserialize<T>(byte[] raw) - перевод массива в объект.
}


	Поскольку речь идет о разных языках, то необходимо сделать допущение.
	Будем исходить из того, что пересылаемый пакет с данными - это пакет с примитивными типами + строки.
Например:

class Packet
{
	int i;
	double d;
	string s;
	Packet p;
}

Подобный класс должен существовать в каждом из языков. Поскольку сериализация на одной стороне,
а десериализация на другой. Общий подход состоит в том, что необходимо с помощью reflection'а
перебрать все поля класса и записать их в массив по некой сигнатуре, например: [ид-типа][имя-поля][значение].
А затем, поскольку десериализация процесс обратный, просто распарсить массив и вернуть объект в исходное состоняие.
Таким образом 4 байта int в Java  перейдут в 4 байта int в С#.

ВАЖНО: Необходимо провести декомпозицию задачи для построения оптимальной структуры классов(Lexer).
Один большой switch-case засчитан не будет.

ВАЖНО: Необходимо сериализовать весь граф объекта. То есть, как в примере, если в объект вложен не примитивный тип,
то необходимо войти в этот объект и сериализовать его поля. Если внутри есть сложный объект, то логика аналогичная.
Очевидно, что структура класса Packet должна быть идентичной в обоих языках.

ВАЖНО: Запрещается пользоваться встроенными сериализаторами по типу автомапинга в json или xml.

ВАЖНО: Необходимо ввести маркер валидности. То есть не все, что приходит по сети, является пакетом.
Проверка маркера валидности позволит определить, возможна ли десериализация в принципе.

Задачи на *:
1. Осуществить сериализацию массива сложных объектов. То есть, речь о сериализации поля вида Packet[] packets.
2. Определение циклических зависимостей.
3. Выполнить исходную задачу с учетом оптимизаций так, чтобы на выходе получать минимального размера массив + zip.
4. Осуществить шифрование массива данных в рамках сессии.

