	Задача №4 - WebSockets- ООП


    Цель данного упражнения познакомить студента с особенностями веб-соектов в Java\С# и, в конечном итоге,
    построить веб-сервер будущего приложения. Далее задача формулируется для Java.


    1. В основе любого сетевого взаимодействия лежат сокеты Беркли, а их реализации существуют во всех языках программирования.
    В Java существует класс-абстракция над сокетами, а именно класс ServerSocket:

	ServerScoket server = new ServerSocket(int port) - единственный параметр - порт, который сервер начинает слушать.
	Если создание серверного сокета завершилось успешно, то это означает, что порт успешно "захвачен" и сервер начал свою работу.
	В прротивном случае будет выброшено исключение. Далее необходимо вызвать метод accept() - данный метод блокирует дальнейшее выполнение
	текущего потока до тех пор, пока не будет зарегистрировано входящее соединение.
	Пример кода:

	ServerScoket server = new ServerSocket(int port);
	Socket client = server.accept(); - здесь происходит блокировка потока пока не появится входящее соединение.
	Переменная client - клиентский сокет.

	InputStream in   = client.getInputStream();  - здесь мы можем взять у клиентского сокета входящий поток и прочитать из него запрос подобно файлу.
    OutputStream out = client.getOutputStream(); - здесь мы можем взять у клиентского сокета исходящий поток и записать в него ответ на запрос.

Соответственно, легко понять что входящий поток на сервере - это исходящий поток на клиенте. А исходящий поток сервера - входящий клиента.
В Java для чтения и записи из сокета используются потоки ввода-вывода. Следовательно, к ним можно применять различные "обертки" подобно работе
с файлом. Необходимо учесть тот факт, что при пересылке большого количества данных необходимо использовать буферизированные "обертки" над потоками.
Имеется ввиду случай, когда клиент еще не закончил писать запрос в поток, а сервер уже начал читать данные.
В таком случае необходимы соглашения о формате и признаке конца запроса.

	Пример клиентского сокета:

	Socket socket = new Socket(ipAddress, serverPort);
	OutputStream out = socket.getOutputStream(); - сюда пишем запрос
	InputStream in = socket.getInputStream();   - отсюда читаем ответ

Это основы, с которыми разобраться будет в общем случае несложно.
Теперь несложно заметить, что построенный таким образом сервер является однопоточным - пока не будет вызван метод accept() -\
входящие соединения не будут приходить.

Выходом из этой ситуации будет следующее:

	1. Поместить метод accept()  внутрь бесконечного цикла.
	2. Как только метод разблокируется, поместить клиентский сокет в другой поток,
	   где будет обработан запрос, и благодаря пункту 1,
	сразу же перейти на новую итерацию цикла и снова вызвать метод accept()

Пример:

	ServerScoket server = new ServerSocket(int port);
	while(true)
	{
		Socket client = server.accept();
		<поместить client в другой поток> 
	}

	Таким образом будет построен многопоточный веб-сервер. 

Теперь можно переходить к формулировке задачи:
Дано: 1. FileWorker, способный считать хэш файлов.
      2. ThreadDispather, способный ставить задачи на выполнение.
      3. WebServer, многопотоный веб-сервер.

Необходимо с использованием все трех механизмов реализовать клиент-серверное приложение, в рамках которого поддерживаются две команды:
    1. list - получить список файлов в директории, на которую смотрит FileWorker.
    2. hash <filename> - получить хэш соответствующего файла.

То есть предельно простая логика - каждая команда отправляется с клиента, на сервере помещается в отдельный поток,
в потоке обрабатывается - результат либо список имен файлов, либо хэш файла,
результат отправляется ответом на запрос и выводится в консоли клиента.

Команды list и hash не потребуются в таком виде в дальнейшем усложнении задачи.
Главная цель упражения - необхождимо сообразно ООП построить основу серверной части будущего веб-прилолжения,
правильно скомпоновав FileWorker, ThreadDispather, WebServer.

Оцениваться будут прежде всего
    1) архитектура серверного приложения,
    2) наличие конфигурационных настроек(порт, ip-адрес...),
    3) механизмов корректной обработки запросов и ответов,
    4) механизма корректной остановки сервера.

Клиент в данном случае имеет пока минимальную роль.

Тестирование: необходимо будет написать специальный тест, который будет с помощью ThreadDispather создавать
одновременно запросы к серверу. На сервере же необходимо с помощью монитора потоков вывести список активных потоков,
где должны быть более одного потока запроса. То есть на каждый запрос клиента монитор потоков должен реагировать.
Ручное тестирование также будет проводиться.


Напоминаю, что допускается соглашение о том, что клиент на одном языке, сервер на другом.
Таким образом FileWorker, ThreadDispather, WebServer должны быть на одном языке, а клиент на другом.
														